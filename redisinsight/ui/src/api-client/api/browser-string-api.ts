/* tslint:disable */
/* eslint-disable */
/**
 * Redis Insight Backend API
 * Redis Insight Backend API
 *
 * The version of the OpenAPI document: 2.70.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { GetKeyInfoDto } from '../models';
// @ts-ignore
import type { GetStringInfoDto } from '../models';
// @ts-ignore
import type { GetStringValueResponse } from '../models';
// @ts-ignore
import type { SetStringDto } from '../models';
// @ts-ignore
import type { SetStringWithExpireDto } from '../models';
/**
 * BrowserStringApi - axios parameter creator
 * @export
 */
export const BrowserStringApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Endpoint do download string value
         * @summary 
         * @param {string} dbInstance 
         * @param {StringControllerDownloadStringFileEncodingEnum} encoding 
         * @param {GetKeyInfoDto} getKeyInfoDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stringControllerDownloadStringFile: async (dbInstance: string, encoding: StringControllerDownloadStringFileEncodingEnum, getKeyInfoDto: GetKeyInfoDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('stringControllerDownloadStringFile', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('stringControllerDownloadStringFile', 'encoding', encoding)
            // verify required parameter 'getKeyInfoDto' is not null or undefined
            assertParamExists('stringControllerDownloadStringFile', 'getKeyInfoDto', getKeyInfoDto)
            const localVarPath = `/api/databases/{dbInstance}/string/download-value`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getKeyInfoDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get string value
         * @summary 
         * @param {string} dbInstance 
         * @param {StringControllerGetStringValueEncodingEnum} encoding 
         * @param {GetStringInfoDto} getStringInfoDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stringControllerGetStringValue: async (dbInstance: string, encoding: StringControllerGetStringValueEncodingEnum, getStringInfoDto: GetStringInfoDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('stringControllerGetStringValue', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('stringControllerGetStringValue', 'encoding', encoding)
            // verify required parameter 'getStringInfoDto' is not null or undefined
            assertParamExists('stringControllerGetStringValue', 'getStringInfoDto', getStringInfoDto)
            const localVarPath = `/api/databases/{dbInstance}/string/get-value`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getStringInfoDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set key to hold string value
         * @summary 
         * @param {string} dbInstance 
         * @param {StringControllerSetStringEncodingEnum} encoding 
         * @param {SetStringWithExpireDto} setStringWithExpireDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stringControllerSetString: async (dbInstance: string, encoding: StringControllerSetStringEncodingEnum, setStringWithExpireDto: SetStringWithExpireDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('stringControllerSetString', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('stringControllerSetString', 'encoding', encoding)
            // verify required parameter 'setStringWithExpireDto' is not null or undefined
            assertParamExists('stringControllerSetString', 'setStringWithExpireDto', setStringWithExpireDto)
            const localVarPath = `/api/databases/{dbInstance}/string`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setStringWithExpireDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update string value
         * @summary 
         * @param {string} dbInstance 
         * @param {StringControllerUpdateStringValueEncodingEnum} encoding 
         * @param {SetStringDto} setStringDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stringControllerUpdateStringValue: async (dbInstance: string, encoding: StringControllerUpdateStringValueEncodingEnum, setStringDto: SetStringDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('stringControllerUpdateStringValue', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('stringControllerUpdateStringValue', 'encoding', encoding)
            // verify required parameter 'setStringDto' is not null or undefined
            assertParamExists('stringControllerUpdateStringValue', 'setStringDto', setStringDto)
            const localVarPath = `/api/databases/{dbInstance}/string`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setStringDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BrowserStringApi - functional programming interface
 * @export
 */
export const BrowserStringApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BrowserStringApiAxiosParamCreator(configuration)
    return {
        /**
         * Endpoint do download string value
         * @summary 
         * @param {string} dbInstance 
         * @param {StringControllerDownloadStringFileEncodingEnum} encoding 
         * @param {GetKeyInfoDto} getKeyInfoDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stringControllerDownloadStringFile(dbInstance: string, encoding: StringControllerDownloadStringFileEncodingEnum, getKeyInfoDto: GetKeyInfoDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stringControllerDownloadStringFile(dbInstance, encoding, getKeyInfoDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserStringApi.stringControllerDownloadStringFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get string value
         * @summary 
         * @param {string} dbInstance 
         * @param {StringControllerGetStringValueEncodingEnum} encoding 
         * @param {GetStringInfoDto} getStringInfoDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stringControllerGetStringValue(dbInstance: string, encoding: StringControllerGetStringValueEncodingEnum, getStringInfoDto: GetStringInfoDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStringValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stringControllerGetStringValue(dbInstance, encoding, getStringInfoDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserStringApi.stringControllerGetStringValue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set key to hold string value
         * @summary 
         * @param {string} dbInstance 
         * @param {StringControllerSetStringEncodingEnum} encoding 
         * @param {SetStringWithExpireDto} setStringWithExpireDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stringControllerSetString(dbInstance: string, encoding: StringControllerSetStringEncodingEnum, setStringWithExpireDto: SetStringWithExpireDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stringControllerSetString(dbInstance, encoding, setStringWithExpireDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserStringApi.stringControllerSetString']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update string value
         * @summary 
         * @param {string} dbInstance 
         * @param {StringControllerUpdateStringValueEncodingEnum} encoding 
         * @param {SetStringDto} setStringDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stringControllerUpdateStringValue(dbInstance: string, encoding: StringControllerUpdateStringValueEncodingEnum, setStringDto: SetStringDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stringControllerUpdateStringValue(dbInstance, encoding, setStringDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserStringApi.stringControllerUpdateStringValue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BrowserStringApi - factory interface
 * @export
 */
export const BrowserStringApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BrowserStringApiFp(configuration)
    return {
        /**
         * Endpoint do download string value
         * @summary 
         * @param {string} dbInstance 
         * @param {StringControllerDownloadStringFileEncodingEnum} encoding 
         * @param {GetKeyInfoDto} getKeyInfoDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stringControllerDownloadStringFile(dbInstance: string, encoding: StringControllerDownloadStringFileEncodingEnum, getKeyInfoDto: GetKeyInfoDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.stringControllerDownloadStringFile(dbInstance, encoding, getKeyInfoDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Get string value
         * @summary 
         * @param {string} dbInstance 
         * @param {StringControllerGetStringValueEncodingEnum} encoding 
         * @param {GetStringInfoDto} getStringInfoDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stringControllerGetStringValue(dbInstance: string, encoding: StringControllerGetStringValueEncodingEnum, getStringInfoDto: GetStringInfoDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<GetStringValueResponse> {
            return localVarFp.stringControllerGetStringValue(dbInstance, encoding, getStringInfoDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Set key to hold string value
         * @summary 
         * @param {string} dbInstance 
         * @param {StringControllerSetStringEncodingEnum} encoding 
         * @param {SetStringWithExpireDto} setStringWithExpireDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stringControllerSetString(dbInstance: string, encoding: StringControllerSetStringEncodingEnum, setStringWithExpireDto: SetStringWithExpireDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.stringControllerSetString(dbInstance, encoding, setStringWithExpireDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Update string value
         * @summary 
         * @param {string} dbInstance 
         * @param {StringControllerUpdateStringValueEncodingEnum} encoding 
         * @param {SetStringDto} setStringDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stringControllerUpdateStringValue(dbInstance: string, encoding: StringControllerUpdateStringValueEncodingEnum, setStringDto: SetStringDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.stringControllerUpdateStringValue(dbInstance, encoding, setStringDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BrowserStringApi - object-oriented interface
 * @export
 * @class BrowserStringApi
 * @extends {BaseAPI}
 */
export class BrowserStringApi extends BaseAPI {
    /**
     * Endpoint do download string value
     * @summary 
     * @param {string} dbInstance 
     * @param {StringControllerDownloadStringFileEncodingEnum} encoding 
     * @param {GetKeyInfoDto} getKeyInfoDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserStringApi
     */
    public stringControllerDownloadStringFile(dbInstance: string, encoding: StringControllerDownloadStringFileEncodingEnum, getKeyInfoDto: GetKeyInfoDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserStringApiFp(this.configuration).stringControllerDownloadStringFile(dbInstance, encoding, getKeyInfoDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get string value
     * @summary 
     * @param {string} dbInstance 
     * @param {StringControllerGetStringValueEncodingEnum} encoding 
     * @param {GetStringInfoDto} getStringInfoDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserStringApi
     */
    public stringControllerGetStringValue(dbInstance: string, encoding: StringControllerGetStringValueEncodingEnum, getStringInfoDto: GetStringInfoDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserStringApiFp(this.configuration).stringControllerGetStringValue(dbInstance, encoding, getStringInfoDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set key to hold string value
     * @summary 
     * @param {string} dbInstance 
     * @param {StringControllerSetStringEncodingEnum} encoding 
     * @param {SetStringWithExpireDto} setStringWithExpireDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserStringApi
     */
    public stringControllerSetString(dbInstance: string, encoding: StringControllerSetStringEncodingEnum, setStringWithExpireDto: SetStringWithExpireDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserStringApiFp(this.configuration).stringControllerSetString(dbInstance, encoding, setStringWithExpireDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update string value
     * @summary 
     * @param {string} dbInstance 
     * @param {StringControllerUpdateStringValueEncodingEnum} encoding 
     * @param {SetStringDto} setStringDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserStringApi
     */
    public stringControllerUpdateStringValue(dbInstance: string, encoding: StringControllerUpdateStringValueEncodingEnum, setStringDto: SetStringDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserStringApiFp(this.configuration).stringControllerUpdateStringValue(dbInstance, encoding, setStringDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const StringControllerDownloadStringFileEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type StringControllerDownloadStringFileEncodingEnum = typeof StringControllerDownloadStringFileEncodingEnum[keyof typeof StringControllerDownloadStringFileEncodingEnum];
/**
 * @export
 */
export const StringControllerGetStringValueEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type StringControllerGetStringValueEncodingEnum = typeof StringControllerGetStringValueEncodingEnum[keyof typeof StringControllerGetStringValueEncodingEnum];
/**
 * @export
 */
export const StringControllerSetStringEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type StringControllerSetStringEncodingEnum = typeof StringControllerSetStringEncodingEnum[keyof typeof StringControllerSetStringEncodingEnum];
/**
 * @export
 */
export const StringControllerUpdateStringValueEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type StringControllerUpdateStringValueEncodingEnum = typeof StringControllerUpdateStringValueEncodingEnum[keyof typeof StringControllerUpdateStringValueEncodingEnum];
