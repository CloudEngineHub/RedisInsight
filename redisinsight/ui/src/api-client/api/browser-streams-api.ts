/* tslint:disable */
/* eslint-disable */
/**
 * Redis Insight Backend API
 * Redis Insight Backend API
 *
 * The version of the OpenAPI document: 2.70.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { AckPendingEntriesDto } from '../models';
// @ts-ignore
import type { AckPendingEntriesResponse } from '../models';
// @ts-ignore
import type { AddStreamEntriesDto } from '../models';
// @ts-ignore
import type { AddStreamEntriesResponse } from '../models';
// @ts-ignore
import type { ClaimPendingEntriesResponse } from '../models';
// @ts-ignore
import type { ClaimPendingEntryDto } from '../models';
// @ts-ignore
import type { ConsumerDto } from '../models';
// @ts-ignore
import type { ConsumerGroupDto } from '../models';
// @ts-ignore
import type { CreateConsumerGroupsDto } from '../models';
// @ts-ignore
import type { CreateStreamDto } from '../models';
// @ts-ignore
import type { DeleteConsumerGroupsDto } from '../models';
// @ts-ignore
import type { DeleteConsumerGroupsResponse } from '../models';
// @ts-ignore
import type { DeleteConsumersDto } from '../models';
// @ts-ignore
import type { DeleteStreamEntriesDto } from '../models';
// @ts-ignore
import type { DeleteStreamEntriesResponse } from '../models';
// @ts-ignore
import type { GetConsumersDto } from '../models';
// @ts-ignore
import type { GetPendingEntriesDto } from '../models';
// @ts-ignore
import type { GetStreamEntriesDto } from '../models';
// @ts-ignore
import type { GetStreamEntriesResponse } from '../models';
// @ts-ignore
import type { KeyDto } from '../models';
// @ts-ignore
import type { PendingEntryDto } from '../models';
// @ts-ignore
import type { UpdateConsumerGroupDto } from '../models';
/**
 * BrowserStreamsApi - axios parameter creator
 * @export
 */
export const BrowserStreamsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Ack pending entries
         * @summary 
         * @param {string} dbInstance 
         * @param {AckPendingEntriesDto} ackPendingEntriesDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumerControllerAckPendingEntries: async (dbInstance: string, ackPendingEntriesDto: AckPendingEntriesDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('consumerControllerAckPendingEntries', 'dbInstance', dbInstance)
            // verify required parameter 'ackPendingEntriesDto' is not null or undefined
            assertParamExists('consumerControllerAckPendingEntries', 'ackPendingEntriesDto', ackPendingEntriesDto)
            const localVarPath = `/api/databases/{dbInstance}/streams/consumer-groups/consumers/pending-messages/ack`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ackPendingEntriesDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Claim pending entries
         * @summary 
         * @param {string} dbInstance 
         * @param {ClaimPendingEntryDto} claimPendingEntryDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumerControllerClaimPendingEntries: async (dbInstance: string, claimPendingEntryDto: ClaimPendingEntryDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('consumerControllerClaimPendingEntries', 'dbInstance', dbInstance)
            // verify required parameter 'claimPendingEntryDto' is not null or undefined
            assertParamExists('consumerControllerClaimPendingEntries', 'claimPendingEntryDto', claimPendingEntryDto)
            const localVarPath = `/api/databases/{dbInstance}/streams/consumer-groups/consumers/pending-messages/claim`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(claimPendingEntryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Consumer(s) from the Consumer Group
         * @summary 
         * @param {string} dbInstance 
         * @param {DeleteConsumersDto} deleteConsumersDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumerControllerDeleteConsumers: async (dbInstance: string, deleteConsumersDto: DeleteConsumersDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('consumerControllerDeleteConsumers', 'dbInstance', dbInstance)
            // verify required parameter 'deleteConsumersDto' is not null or undefined
            assertParamExists('consumerControllerDeleteConsumers', 'deleteConsumersDto', deleteConsumersDto)
            const localVarPath = `/api/databases/{dbInstance}/streams/consumer-groups/consumers`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteConsumersDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get consumers list in the group
         * @summary 
         * @param {string} dbInstance 
         * @param {ConsumerControllerGetConsumersEncodingEnum} encoding 
         * @param {GetConsumersDto} getConsumersDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumerControllerGetConsumers: async (dbInstance: string, encoding: ConsumerControllerGetConsumersEncodingEnum, getConsumersDto: GetConsumersDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('consumerControllerGetConsumers', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('consumerControllerGetConsumers', 'encoding', encoding)
            // verify required parameter 'getConsumersDto' is not null or undefined
            assertParamExists('consumerControllerGetConsumers', 'getConsumersDto', getConsumersDto)
            const localVarPath = `/api/databases/{dbInstance}/streams/consumer-groups/consumers/get`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getConsumersDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get pending entries list
         * @summary 
         * @param {string} dbInstance 
         * @param {ConsumerControllerGetPendingEntriesEncodingEnum} encoding 
         * @param {GetPendingEntriesDto} getPendingEntriesDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumerControllerGetPendingEntries: async (dbInstance: string, encoding: ConsumerControllerGetPendingEntriesEncodingEnum, getPendingEntriesDto: GetPendingEntriesDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('consumerControllerGetPendingEntries', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('consumerControllerGetPendingEntries', 'encoding', encoding)
            // verify required parameter 'getPendingEntriesDto' is not null or undefined
            assertParamExists('consumerControllerGetPendingEntries', 'getPendingEntriesDto', getPendingEntriesDto)
            const localVarPath = `/api/databases/{dbInstance}/streams/consumer-groups/consumers/pending-messages/get`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getPendingEntriesDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create stream consumer group
         * @summary 
         * @param {string} dbInstance 
         * @param {CreateConsumerGroupsDto} createConsumerGroupsDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumerGroupControllerCreateGroups: async (dbInstance: string, createConsumerGroupsDto: CreateConsumerGroupsDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('consumerGroupControllerCreateGroups', 'dbInstance', dbInstance)
            // verify required parameter 'createConsumerGroupsDto' is not null or undefined
            assertParamExists('consumerGroupControllerCreateGroups', 'createConsumerGroupsDto', createConsumerGroupsDto)
            const localVarPath = `/api/databases/{dbInstance}/streams/consumer-groups`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createConsumerGroupsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete Consumer Group
         * @summary 
         * @param {string} dbInstance 
         * @param {DeleteConsumerGroupsDto} deleteConsumerGroupsDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumerGroupControllerDeleteGroup: async (dbInstance: string, deleteConsumerGroupsDto: DeleteConsumerGroupsDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('consumerGroupControllerDeleteGroup', 'dbInstance', dbInstance)
            // verify required parameter 'deleteConsumerGroupsDto' is not null or undefined
            assertParamExists('consumerGroupControllerDeleteGroup', 'deleteConsumerGroupsDto', deleteConsumerGroupsDto)
            const localVarPath = `/api/databases/{dbInstance}/streams/consumer-groups`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteConsumerGroupsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get consumer groups list
         * @summary 
         * @param {string} dbInstance 
         * @param {ConsumerGroupControllerGetGroupsEncodingEnum} encoding 
         * @param {KeyDto} keyDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumerGroupControllerGetGroups: async (dbInstance: string, encoding: ConsumerGroupControllerGetGroupsEncodingEnum, keyDto: KeyDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('consumerGroupControllerGetGroups', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('consumerGroupControllerGetGroups', 'encoding', encoding)
            // verify required parameter 'keyDto' is not null or undefined
            assertParamExists('consumerGroupControllerGetGroups', 'keyDto', keyDto)
            const localVarPath = `/api/databases/{dbInstance}/streams/consumer-groups/get`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(keyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify last delivered ID of the Consumer Group
         * @summary 
         * @param {string} dbInstance 
         * @param {UpdateConsumerGroupDto} updateConsumerGroupDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumerGroupControllerUpdateGroup: async (dbInstance: string, updateConsumerGroupDto: UpdateConsumerGroupDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('consumerGroupControllerUpdateGroup', 'dbInstance', dbInstance)
            // verify required parameter 'updateConsumerGroupDto' is not null or undefined
            assertParamExists('consumerGroupControllerUpdateGroup', 'updateConsumerGroupDto', updateConsumerGroupDto)
            const localVarPath = `/api/databases/{dbInstance}/streams/consumer-groups`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateConsumerGroupDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add entries to the stream
         * @summary 
         * @param {string} dbInstance 
         * @param {StreamControllerAddEntriesEncodingEnum} encoding 
         * @param {AddStreamEntriesDto} addStreamEntriesDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamControllerAddEntries: async (dbInstance: string, encoding: StreamControllerAddEntriesEncodingEnum, addStreamEntriesDto: AddStreamEntriesDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('streamControllerAddEntries', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('streamControllerAddEntries', 'encoding', encoding)
            // verify required parameter 'addStreamEntriesDto' is not null or undefined
            assertParamExists('streamControllerAddEntries', 'addStreamEntriesDto', addStreamEntriesDto)
            const localVarPath = `/api/databases/{dbInstance}/streams/entries`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addStreamEntriesDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create stream
         * @summary 
         * @param {string} dbInstance 
         * @param {CreateStreamDto} createStreamDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamControllerCreateStream: async (dbInstance: string, createStreamDto: CreateStreamDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('streamControllerCreateStream', 'dbInstance', dbInstance)
            // verify required parameter 'createStreamDto' is not null or undefined
            assertParamExists('streamControllerCreateStream', 'createStreamDto', createStreamDto)
            const localVarPath = `/api/databases/{dbInstance}/streams`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createStreamDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove the specified entries from the Stream stored at key
         * @summary 
         * @param {string} dbInstance 
         * @param {DeleteStreamEntriesDto} deleteStreamEntriesDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamControllerDeleteEntries: async (dbInstance: string, deleteStreamEntriesDto: DeleteStreamEntriesDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('streamControllerDeleteEntries', 'dbInstance', dbInstance)
            // verify required parameter 'deleteStreamEntriesDto' is not null or undefined
            assertParamExists('streamControllerDeleteEntries', 'deleteStreamEntriesDto', deleteStreamEntriesDto)
            const localVarPath = `/api/databases/{dbInstance}/streams/entries`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteStreamEntriesDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get stream entries
         * @summary 
         * @param {string} dbInstance 
         * @param {StreamControllerGetEntriesEncodingEnum} encoding 
         * @param {GetStreamEntriesDto} getStreamEntriesDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamControllerGetEntries: async (dbInstance: string, encoding: StreamControllerGetEntriesEncodingEnum, getStreamEntriesDto: GetStreamEntriesDto, riDbIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbInstance' is not null or undefined
            assertParamExists('streamControllerGetEntries', 'dbInstance', dbInstance)
            // verify required parameter 'encoding' is not null or undefined
            assertParamExists('streamControllerGetEntries', 'encoding', encoding)
            // verify required parameter 'getStreamEntriesDto' is not null or undefined
            assertParamExists('streamControllerGetEntries', 'getStreamEntriesDto', getStreamEntriesDto)
            const localVarPath = `/api/databases/{dbInstance}/streams/entries/get`
                .replace(`{${"dbInstance"}}`, encodeURIComponent(String(dbInstance)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (encoding !== undefined) {
                localVarQueryParameter['encoding'] = encoding;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (riDbIndex != null) {
                localVarHeaderParameter['ri-db-index'] = typeof riDbIndex === 'string'
                    ? riDbIndex
                    : JSON.stringify(riDbIndex);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getStreamEntriesDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BrowserStreamsApi - functional programming interface
 * @export
 */
export const BrowserStreamsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BrowserStreamsApiAxiosParamCreator(configuration)
    return {
        /**
         * Ack pending entries
         * @summary 
         * @param {string} dbInstance 
         * @param {AckPendingEntriesDto} ackPendingEntriesDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async consumerControllerAckPendingEntries(dbInstance: string, ackPendingEntriesDto: AckPendingEntriesDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AckPendingEntriesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.consumerControllerAckPendingEntries(dbInstance, ackPendingEntriesDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserStreamsApi.consumerControllerAckPendingEntries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Claim pending entries
         * @summary 
         * @param {string} dbInstance 
         * @param {ClaimPendingEntryDto} claimPendingEntryDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async consumerControllerClaimPendingEntries(dbInstance: string, claimPendingEntryDto: ClaimPendingEntryDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClaimPendingEntriesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.consumerControllerClaimPendingEntries(dbInstance, claimPendingEntryDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserStreamsApi.consumerControllerClaimPendingEntries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete Consumer(s) from the Consumer Group
         * @summary 
         * @param {string} dbInstance 
         * @param {DeleteConsumersDto} deleteConsumersDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async consumerControllerDeleteConsumers(dbInstance: string, deleteConsumersDto: DeleteConsumersDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.consumerControllerDeleteConsumers(dbInstance, deleteConsumersDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserStreamsApi.consumerControllerDeleteConsumers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get consumers list in the group
         * @summary 
         * @param {string} dbInstance 
         * @param {ConsumerControllerGetConsumersEncodingEnum} encoding 
         * @param {GetConsumersDto} getConsumersDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async consumerControllerGetConsumers(dbInstance: string, encoding: ConsumerControllerGetConsumersEncodingEnum, getConsumersDto: GetConsumersDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConsumerDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.consumerControllerGetConsumers(dbInstance, encoding, getConsumersDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserStreamsApi.consumerControllerGetConsumers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get pending entries list
         * @summary 
         * @param {string} dbInstance 
         * @param {ConsumerControllerGetPendingEntriesEncodingEnum} encoding 
         * @param {GetPendingEntriesDto} getPendingEntriesDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async consumerControllerGetPendingEntries(dbInstance: string, encoding: ConsumerControllerGetPendingEntriesEncodingEnum, getPendingEntriesDto: GetPendingEntriesDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PendingEntryDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.consumerControllerGetPendingEntries(dbInstance, encoding, getPendingEntriesDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserStreamsApi.consumerControllerGetPendingEntries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create stream consumer group
         * @summary 
         * @param {string} dbInstance 
         * @param {CreateConsumerGroupsDto} createConsumerGroupsDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async consumerGroupControllerCreateGroups(dbInstance: string, createConsumerGroupsDto: CreateConsumerGroupsDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.consumerGroupControllerCreateGroups(dbInstance, createConsumerGroupsDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserStreamsApi.consumerGroupControllerCreateGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete Consumer Group
         * @summary 
         * @param {string} dbInstance 
         * @param {DeleteConsumerGroupsDto} deleteConsumerGroupsDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async consumerGroupControllerDeleteGroup(dbInstance: string, deleteConsumerGroupsDto: DeleteConsumerGroupsDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteConsumerGroupsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.consumerGroupControllerDeleteGroup(dbInstance, deleteConsumerGroupsDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserStreamsApi.consumerGroupControllerDeleteGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get consumer groups list
         * @summary 
         * @param {string} dbInstance 
         * @param {ConsumerGroupControllerGetGroupsEncodingEnum} encoding 
         * @param {KeyDto} keyDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async consumerGroupControllerGetGroups(dbInstance: string, encoding: ConsumerGroupControllerGetGroupsEncodingEnum, keyDto: KeyDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConsumerGroupDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.consumerGroupControllerGetGroups(dbInstance, encoding, keyDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserStreamsApi.consumerGroupControllerGetGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Modify last delivered ID of the Consumer Group
         * @summary 
         * @param {string} dbInstance 
         * @param {UpdateConsumerGroupDto} updateConsumerGroupDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async consumerGroupControllerUpdateGroup(dbInstance: string, updateConsumerGroupDto: UpdateConsumerGroupDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.consumerGroupControllerUpdateGroup(dbInstance, updateConsumerGroupDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserStreamsApi.consumerGroupControllerUpdateGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add entries to the stream
         * @summary 
         * @param {string} dbInstance 
         * @param {StreamControllerAddEntriesEncodingEnum} encoding 
         * @param {AddStreamEntriesDto} addStreamEntriesDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamControllerAddEntries(dbInstance: string, encoding: StreamControllerAddEntriesEncodingEnum, addStreamEntriesDto: AddStreamEntriesDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddStreamEntriesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.streamControllerAddEntries(dbInstance, encoding, addStreamEntriesDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserStreamsApi.streamControllerAddEntries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create stream
         * @summary 
         * @param {string} dbInstance 
         * @param {CreateStreamDto} createStreamDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamControllerCreateStream(dbInstance: string, createStreamDto: CreateStreamDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.streamControllerCreateStream(dbInstance, createStreamDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserStreamsApi.streamControllerCreateStream']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove the specified entries from the Stream stored at key
         * @summary 
         * @param {string} dbInstance 
         * @param {DeleteStreamEntriesDto} deleteStreamEntriesDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamControllerDeleteEntries(dbInstance: string, deleteStreamEntriesDto: DeleteStreamEntriesDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteStreamEntriesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.streamControllerDeleteEntries(dbInstance, deleteStreamEntriesDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserStreamsApi.streamControllerDeleteEntries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get stream entries
         * @summary 
         * @param {string} dbInstance 
         * @param {StreamControllerGetEntriesEncodingEnum} encoding 
         * @param {GetStreamEntriesDto} getStreamEntriesDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamControllerGetEntries(dbInstance: string, encoding: StreamControllerGetEntriesEncodingEnum, getStreamEntriesDto: GetStreamEntriesDto, riDbIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStreamEntriesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.streamControllerGetEntries(dbInstance, encoding, getStreamEntriesDto, riDbIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserStreamsApi.streamControllerGetEntries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BrowserStreamsApi - factory interface
 * @export
 */
export const BrowserStreamsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BrowserStreamsApiFp(configuration)
    return {
        /**
         * Ack pending entries
         * @summary 
         * @param {string} dbInstance 
         * @param {AckPendingEntriesDto} ackPendingEntriesDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumerControllerAckPendingEntries(dbInstance: string, ackPendingEntriesDto: AckPendingEntriesDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<AckPendingEntriesResponse> {
            return localVarFp.consumerControllerAckPendingEntries(dbInstance, ackPendingEntriesDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Claim pending entries
         * @summary 
         * @param {string} dbInstance 
         * @param {ClaimPendingEntryDto} claimPendingEntryDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumerControllerClaimPendingEntries(dbInstance: string, claimPendingEntryDto: ClaimPendingEntryDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<ClaimPendingEntriesResponse> {
            return localVarFp.consumerControllerClaimPendingEntries(dbInstance, claimPendingEntryDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Consumer(s) from the Consumer Group
         * @summary 
         * @param {string} dbInstance 
         * @param {DeleteConsumersDto} deleteConsumersDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumerControllerDeleteConsumers(dbInstance: string, deleteConsumersDto: DeleteConsumersDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.consumerControllerDeleteConsumers(dbInstance, deleteConsumersDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Get consumers list in the group
         * @summary 
         * @param {string} dbInstance 
         * @param {ConsumerControllerGetConsumersEncodingEnum} encoding 
         * @param {GetConsumersDto} getConsumersDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumerControllerGetConsumers(dbInstance: string, encoding: ConsumerControllerGetConsumersEncodingEnum, getConsumersDto: GetConsumersDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<ConsumerDto>> {
            return localVarFp.consumerControllerGetConsumers(dbInstance, encoding, getConsumersDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Get pending entries list
         * @summary 
         * @param {string} dbInstance 
         * @param {ConsumerControllerGetPendingEntriesEncodingEnum} encoding 
         * @param {GetPendingEntriesDto} getPendingEntriesDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumerControllerGetPendingEntries(dbInstance: string, encoding: ConsumerControllerGetPendingEntriesEncodingEnum, getPendingEntriesDto: GetPendingEntriesDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<PendingEntryDto>> {
            return localVarFp.consumerControllerGetPendingEntries(dbInstance, encoding, getPendingEntriesDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Create stream consumer group
         * @summary 
         * @param {string} dbInstance 
         * @param {CreateConsumerGroupsDto} createConsumerGroupsDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumerGroupControllerCreateGroups(dbInstance: string, createConsumerGroupsDto: CreateConsumerGroupsDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.consumerGroupControllerCreateGroups(dbInstance, createConsumerGroupsDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete Consumer Group
         * @summary 
         * @param {string} dbInstance 
         * @param {DeleteConsumerGroupsDto} deleteConsumerGroupsDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumerGroupControllerDeleteGroup(dbInstance: string, deleteConsumerGroupsDto: DeleteConsumerGroupsDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<DeleteConsumerGroupsResponse> {
            return localVarFp.consumerGroupControllerDeleteGroup(dbInstance, deleteConsumerGroupsDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Get consumer groups list
         * @summary 
         * @param {string} dbInstance 
         * @param {ConsumerGroupControllerGetGroupsEncodingEnum} encoding 
         * @param {KeyDto} keyDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumerGroupControllerGetGroups(dbInstance: string, encoding: ConsumerGroupControllerGetGroupsEncodingEnum, keyDto: KeyDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<ConsumerGroupDto>> {
            return localVarFp.consumerGroupControllerGetGroups(dbInstance, encoding, keyDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify last delivered ID of the Consumer Group
         * @summary 
         * @param {string} dbInstance 
         * @param {UpdateConsumerGroupDto} updateConsumerGroupDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consumerGroupControllerUpdateGroup(dbInstance: string, updateConsumerGroupDto: UpdateConsumerGroupDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.consumerGroupControllerUpdateGroup(dbInstance, updateConsumerGroupDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Add entries to the stream
         * @summary 
         * @param {string} dbInstance 
         * @param {StreamControllerAddEntriesEncodingEnum} encoding 
         * @param {AddStreamEntriesDto} addStreamEntriesDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamControllerAddEntries(dbInstance: string, encoding: StreamControllerAddEntriesEncodingEnum, addStreamEntriesDto: AddStreamEntriesDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<AddStreamEntriesResponse> {
            return localVarFp.streamControllerAddEntries(dbInstance, encoding, addStreamEntriesDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Create stream
         * @summary 
         * @param {string} dbInstance 
         * @param {CreateStreamDto} createStreamDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamControllerCreateStream(dbInstance: string, createStreamDto: CreateStreamDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.streamControllerCreateStream(dbInstance, createStreamDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove the specified entries from the Stream stored at key
         * @summary 
         * @param {string} dbInstance 
         * @param {DeleteStreamEntriesDto} deleteStreamEntriesDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamControllerDeleteEntries(dbInstance: string, deleteStreamEntriesDto: DeleteStreamEntriesDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<DeleteStreamEntriesResponse> {
            return localVarFp.streamControllerDeleteEntries(dbInstance, deleteStreamEntriesDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Get stream entries
         * @summary 
         * @param {string} dbInstance 
         * @param {StreamControllerGetEntriesEncodingEnum} encoding 
         * @param {GetStreamEntriesDto} getStreamEntriesDto 
         * @param {number} [riDbIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamControllerGetEntries(dbInstance: string, encoding: StreamControllerGetEntriesEncodingEnum, getStreamEntriesDto: GetStreamEntriesDto, riDbIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<GetStreamEntriesResponse> {
            return localVarFp.streamControllerGetEntries(dbInstance, encoding, getStreamEntriesDto, riDbIndex, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BrowserStreamsApi - object-oriented interface
 * @export
 * @class BrowserStreamsApi
 * @extends {BaseAPI}
 */
export class BrowserStreamsApi extends BaseAPI {
    /**
     * Ack pending entries
     * @summary 
     * @param {string} dbInstance 
     * @param {AckPendingEntriesDto} ackPendingEntriesDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserStreamsApi
     */
    public consumerControllerAckPendingEntries(dbInstance: string, ackPendingEntriesDto: AckPendingEntriesDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserStreamsApiFp(this.configuration).consumerControllerAckPendingEntries(dbInstance, ackPendingEntriesDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Claim pending entries
     * @summary 
     * @param {string} dbInstance 
     * @param {ClaimPendingEntryDto} claimPendingEntryDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserStreamsApi
     */
    public consumerControllerClaimPendingEntries(dbInstance: string, claimPendingEntryDto: ClaimPendingEntryDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserStreamsApiFp(this.configuration).consumerControllerClaimPendingEntries(dbInstance, claimPendingEntryDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete Consumer(s) from the Consumer Group
     * @summary 
     * @param {string} dbInstance 
     * @param {DeleteConsumersDto} deleteConsumersDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserStreamsApi
     */
    public consumerControllerDeleteConsumers(dbInstance: string, deleteConsumersDto: DeleteConsumersDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserStreamsApiFp(this.configuration).consumerControllerDeleteConsumers(dbInstance, deleteConsumersDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get consumers list in the group
     * @summary 
     * @param {string} dbInstance 
     * @param {ConsumerControllerGetConsumersEncodingEnum} encoding 
     * @param {GetConsumersDto} getConsumersDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserStreamsApi
     */
    public consumerControllerGetConsumers(dbInstance: string, encoding: ConsumerControllerGetConsumersEncodingEnum, getConsumersDto: GetConsumersDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserStreamsApiFp(this.configuration).consumerControllerGetConsumers(dbInstance, encoding, getConsumersDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get pending entries list
     * @summary 
     * @param {string} dbInstance 
     * @param {ConsumerControllerGetPendingEntriesEncodingEnum} encoding 
     * @param {GetPendingEntriesDto} getPendingEntriesDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserStreamsApi
     */
    public consumerControllerGetPendingEntries(dbInstance: string, encoding: ConsumerControllerGetPendingEntriesEncodingEnum, getPendingEntriesDto: GetPendingEntriesDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserStreamsApiFp(this.configuration).consumerControllerGetPendingEntries(dbInstance, encoding, getPendingEntriesDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create stream consumer group
     * @summary 
     * @param {string} dbInstance 
     * @param {CreateConsumerGroupsDto} createConsumerGroupsDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserStreamsApi
     */
    public consumerGroupControllerCreateGroups(dbInstance: string, createConsumerGroupsDto: CreateConsumerGroupsDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserStreamsApiFp(this.configuration).consumerGroupControllerCreateGroups(dbInstance, createConsumerGroupsDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete Consumer Group
     * @summary 
     * @param {string} dbInstance 
     * @param {DeleteConsumerGroupsDto} deleteConsumerGroupsDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserStreamsApi
     */
    public consumerGroupControllerDeleteGroup(dbInstance: string, deleteConsumerGroupsDto: DeleteConsumerGroupsDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserStreamsApiFp(this.configuration).consumerGroupControllerDeleteGroup(dbInstance, deleteConsumerGroupsDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get consumer groups list
     * @summary 
     * @param {string} dbInstance 
     * @param {ConsumerGroupControllerGetGroupsEncodingEnum} encoding 
     * @param {KeyDto} keyDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserStreamsApi
     */
    public consumerGroupControllerGetGroups(dbInstance: string, encoding: ConsumerGroupControllerGetGroupsEncodingEnum, keyDto: KeyDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserStreamsApiFp(this.configuration).consumerGroupControllerGetGroups(dbInstance, encoding, keyDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modify last delivered ID of the Consumer Group
     * @summary 
     * @param {string} dbInstance 
     * @param {UpdateConsumerGroupDto} updateConsumerGroupDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserStreamsApi
     */
    public consumerGroupControllerUpdateGroup(dbInstance: string, updateConsumerGroupDto: UpdateConsumerGroupDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserStreamsApiFp(this.configuration).consumerGroupControllerUpdateGroup(dbInstance, updateConsumerGroupDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add entries to the stream
     * @summary 
     * @param {string} dbInstance 
     * @param {StreamControllerAddEntriesEncodingEnum} encoding 
     * @param {AddStreamEntriesDto} addStreamEntriesDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserStreamsApi
     */
    public streamControllerAddEntries(dbInstance: string, encoding: StreamControllerAddEntriesEncodingEnum, addStreamEntriesDto: AddStreamEntriesDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserStreamsApiFp(this.configuration).streamControllerAddEntries(dbInstance, encoding, addStreamEntriesDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create stream
     * @summary 
     * @param {string} dbInstance 
     * @param {CreateStreamDto} createStreamDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserStreamsApi
     */
    public streamControllerCreateStream(dbInstance: string, createStreamDto: CreateStreamDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserStreamsApiFp(this.configuration).streamControllerCreateStream(dbInstance, createStreamDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove the specified entries from the Stream stored at key
     * @summary 
     * @param {string} dbInstance 
     * @param {DeleteStreamEntriesDto} deleteStreamEntriesDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserStreamsApi
     */
    public streamControllerDeleteEntries(dbInstance: string, deleteStreamEntriesDto: DeleteStreamEntriesDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserStreamsApiFp(this.configuration).streamControllerDeleteEntries(dbInstance, deleteStreamEntriesDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get stream entries
     * @summary 
     * @param {string} dbInstance 
     * @param {StreamControllerGetEntriesEncodingEnum} encoding 
     * @param {GetStreamEntriesDto} getStreamEntriesDto 
     * @param {number} [riDbIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrowserStreamsApi
     */
    public streamControllerGetEntries(dbInstance: string, encoding: StreamControllerGetEntriesEncodingEnum, getStreamEntriesDto: GetStreamEntriesDto, riDbIndex?: number, options?: RawAxiosRequestConfig) {
        return BrowserStreamsApiFp(this.configuration).streamControllerGetEntries(dbInstance, encoding, getStreamEntriesDto, riDbIndex, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ConsumerControllerGetConsumersEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type ConsumerControllerGetConsumersEncodingEnum = typeof ConsumerControllerGetConsumersEncodingEnum[keyof typeof ConsumerControllerGetConsumersEncodingEnum];
/**
 * @export
 */
export const ConsumerControllerGetPendingEntriesEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type ConsumerControllerGetPendingEntriesEncodingEnum = typeof ConsumerControllerGetPendingEntriesEncodingEnum[keyof typeof ConsumerControllerGetPendingEntriesEncodingEnum];
/**
 * @export
 */
export const ConsumerGroupControllerGetGroupsEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type ConsumerGroupControllerGetGroupsEncodingEnum = typeof ConsumerGroupControllerGetGroupsEncodingEnum[keyof typeof ConsumerGroupControllerGetGroupsEncodingEnum];
/**
 * @export
 */
export const StreamControllerAddEntriesEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type StreamControllerAddEntriesEncodingEnum = typeof StreamControllerAddEntriesEncodingEnum[keyof typeof StreamControllerAddEntriesEncodingEnum];
/**
 * @export
 */
export const StreamControllerGetEntriesEncodingEnum = {
    Utf8: 'utf8',
    Ascii: 'ascii',
    Buffer: 'buffer'
} as const;
export type StreamControllerGetEntriesEncodingEnum = typeof StreamControllerGetEntriesEncodingEnum[keyof typeof StreamControllerGetEntriesEncodingEnum];
